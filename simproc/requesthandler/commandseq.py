"""Requests that include command sequences"""

#Standard library
from __future__ import print_function, division #Python 2 compatibility

#Site packages

#This package
from . import yaml_manager
from . import customization

class WithCommandsRequest(customization.CustomizableRequest):
  """A customizeable request that supports command sequences"""
  def process_command_sequence(self,attrpath,singlefunc=None,positional=False):
    """Process a list of commands

    Arguments:

      - attrpath = attribute path to the command list
      - singlefunc = the name (as string) of the method to be called for all items in the sequence.
        Set this to ``None`` if the command list must include the function name.
        Otherwise, the command list will consist only of the arguments.
      - positional = boolean, True to use positional arguments, False to use keyword arguments
        If False, the arguments are provided as a dictionary.
        If True, the arguments are provided as a sequence.

    No return value."""
    if singlefunc is not None:
      funcname = singlefunc
    for cmd in self.get_nested(attrpath):
      try:
        #Function name and arguments
        if singlefunc is None:
          funcname, arguments = cmd
        else:
          arguments = cmd
        #Call it
        if positional:
          getattr(self,funcname)(*arguments)
        else:
          getattr(self,funcname)(**arguments)
      except Exception as einst:
        print("Exception occured in %s for command: %s"%(attrpath,str(cmd)), file=sys.stderr)
        raise einst
    return
  def list_iofiles(self,cmdlist,filearg_list=None,helper_tag=None):
    """Get a list of all the input/output files generated by a comamnd sequence.

    Arguments:

      - cmdlist = list of commands,
        each command consists of pair (cmdname, arguments):

          - cmdname = name of data extraction method of the simulator class
          - arguments = dictionary of all arguments needed by the extraction method

      - filearg_list = list of command arguments potentially containing files
      - helper_tag = suffix to add to the command names to get the helper function for that command
          A helper function will provide the input/output files when called.

    Return:

      - iofiles = list of input/output files, in the form passed in the command list"""
    #List of arguments that may contain output filenames
    if filearg_list is None:
      filearg_list=['filename','outfpath']
    #Helper tags
    if helper_tag is None:
      helper_tag = '_outputfiles'
    #Initalize the output list
    iofiles=[]
    #Go through all commands in the list
    for cmdname, arguments in cmdlist:
      helperfunc=cmdname+helper_tag
      if hasattr(self,helperfunc):
        iofiles += getattr(self,helperfunc)(**arguments)
      else:
        #Check all possible arguments that could contain the name of an output file
        present_args=[n for n in filearg_list if n in arguments.keys()]
        iofiles += [arguments[n] for n in present_args]
    return iofiles

#Convenience function for schema updates
make_schema=WithCommandsRequest.update_props_schema

_CommandSequenceRequest_props_schema_yaml="""#CommandSequenceRequest
commands:
  type: array"""

class CommandSequenceRequest(WithCommandsRequest):
  """A request to just run a sequence of commands

  User-defined attributes:
  
    - commands = sequence of commands to execute

      Each command is a pair (cmdname, arguments), where:

        - cmdname = name of the object's method to call, as a string
        - arguments = dictionary of arguments to the method: {argname: value,...}"""
  _self_task=True
  _config_attrs=('commands',)
  _required_attrs=['commands']
  _props_schema=make_schema(_CommandSequenceRequest_props_schema_yaml)
  def __init__(self,**kwargs):
    #Initialization from base class
    super(CommandSequenceRequest, self).__init__(**kwargs)
    #Get output files from data extraction commands
    self._more_outputfiles=getattr(self,'_more_outputfiles',[]) #Initialize attribute if it doesn't already exist
    self._more_outputfiles+=self.list_outputfiles(self.commands)
  def run(self):
    #Final checks and preparatory steps
    self.pre_run()
    #Run the comamnd sequence
    self.process_command_sequence(attrpath='commands',singlefunc=None,positional=False)

#Register for loading from yaml
yaml_manager.register_classes([CommandSequenceRequest])
