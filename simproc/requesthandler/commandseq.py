"""Requests that include command sequences"""

#Standard library
from __future__ import print_function, division #Python 2 compatibility
import sys

#Site packages
import pandas as pd

#This package
from . import yaml_manager
from . import pickle_manager
from . import customization

class WithCommandsRequest(customization.CustomizableRequest):
  """A customizeable request that supports command sequences"""

  def process_command_sequence(self,attrpath,singlefunc=None,positional=False):
    """Process a list of commands

    Arguments:

      - attrpath = attribute path to the command list
      - singlefunc = the name (as string) of the method to be called for all items in the sequence.
        Set this to ``None`` if the command list must include the function name.
        Otherwise, the command list will consist only of the arguments.
      - positional = boolean, True to use positional arguments, False to use keyword arguments
        If False, the arguments are provided as a dictionary.
        If True, the arguments are provided as a sequence.

    No return value."""
    if singlefunc is not None:
      funcname = singlefunc
    for cmd in self.get_nested_default(attrpath,[]):
      try:
        #Function name and arguments
        if singlefunc is None:
          funcname, arguments = cmd
        else:
          arguments = cmd
        #Call it
        if positional:
          getattr(self,funcname)(*arguments)
        else:
          getattr(self,funcname)(**arguments)
      except Exception as einst:
        print("Exception occured in %s for command: %s"%(attrpath,str(cmd)), file=sys.stderr)
        raise einst
    return

  def list_iofiles(self,cmdlist,filearg_list=None,helper_tag=None):
    """Get a list of all the input/output files generated by a comamnd sequence.

    Arguments:

      - cmdlist = list of commands,
        each command consists of pair (cmdname, arguments):

          - cmdname = name of data extraction method of the simulator class
          - arguments = dictionary of all arguments needed by the extraction method

      - filearg_list = list of command arguments potentially containing files
      - helper_tag = suffix to add to the command names to get the helper function for that command
          A helper function will provide the input/output files when called.

    Return:

      - iofiles = list of input/output files, in the form passed in the command list"""
    #List of arguments that may contain output filenames
    if filearg_list is None:
      filearg_list=['filename','outfpath']
    #Helper tags
    if helper_tag is None:
      helper_tag = '_outputfiles'
    #Initalize the output list
    iofiles=[]
    #Go through all commands in the list
    for cmdname, arguments in cmdlist:
      helperfunc=cmdname+helper_tag
      if hasattr(self,helperfunc):
        iofiles += getattr(self,helperfunc)(**arguments)
      else:
        #Check all possible arguments that could contain the name of an output file
        present_args=[n for n in filearg_list if n in arguments.keys()]
        iofiles += [arguments[n] for n in present_args]
    return iofiles

  def load_yaml(self,infpath,attrpath):
    """Read in data from a yaml file, and store it at the specified nested path

    Arguments:

      - infpath = path to input yaml file
      - attrpath = nested path to attribute to store data"""
    obj=yaml_manager.readfile(self.render(infpath))
    self.set_nested(attrpath,obj)

  def load_pickle(self,infpath,attrpath):
    """Read in data from a pickle file, and store it at the specified nested path

    Arguments:

      - infpath = path to input pickle file
      - attrpath = nested path to attribute to store data"""
    obj=pickle_manager.readfile(self.render(infpath))
    self.set_nested(attrpath,obj)

  def load_csv(self,infpath,attrpath):
    """Load a CSV file into a dataframe

    Arguments:

      - infpath = path to the input CSV file
      - attrpath = attribute path to load the data into
    
    No return value."""
    fpt=self.renderstr(self.get_stored(infpath))
    df=pd.read_csv(fpt)
    self.set_nested(attrpath,df)
    return

  def save_yaml(self,attrpath,outfpath):
    """Save data from the specified nested path to a yaml file

    Arguments:

      - attrpath = nested path to attribute with data to store
      - outfpath = path to the output yaml file"""
    obj=self.get_nested(attrpath)
    yaml_manager.writefile(obj,self.render(outfpath))

  def save_pickle(self,attrpath,outfpath):
    """Save data from the specified nested path to a pickle file

    Arguments:

      - attrpath = nested path to attribute with data to store
      - outfpath = path to the output pickle file"""
    obj=self.get_nested(attrpath)
    pickle_manager.writefile(obj,self.render(outfpath))

  def save_csv(self,attrpath,outfpath):
    """Save dataframe to a CSV file

    Arguments:

      - attrpath = nested path to attribute with the dataframe to store
      - outfpath = path to the output CSV file"""
    df = self.get_nested(attrpath)
    fpt = self.renderstr(self.get_stored(outfpath))
    df.to_csv(fpt)

  def reportvalues(self,outfpath,mapping):
    """Write the selected output results to a yaml file
    
    Arguments:
    
      - outfpath = path to the output yaml file
      - mapping = mapping of output field names to object paths suitable for get_nested
    
    No attributes modified.
    Output file is created/overwritten.
    No return value."""
    outdict={}
    for key,dpath in mapping.items():
      outdict[key]=self.get_nested(dpath)
    yaml_manager.writefile(outdict,self.render(outfpath))
    return


#Convenience function for schema updates
make_schema=WithCommandsRequest.update_props_schema

_CommandSequenceRequest_props_schema_yaml="""#CommandSequenceRequest
commands:
  type: array"""

class CommandSequenceRequest(WithCommandsRequest):
  """A request to just run a sequence of commands

  User-defined attributes:
  
    - commands = sequence of commands to execute

      Each command is a pair (cmdname, arguments), where:

        - cmdname = name of the object's method to call, as a string
        - arguments = dictionary of arguments to the method: {argname: value,...}"""
  _self_task=True
  _config_attrs=('commands',)
  _required_attrs=['commands']
  _props_schema=make_schema(_CommandSequenceRequest_props_schema_yaml)
  def __init__(self,**kwargs):
    #Initialization from base class
    super(CommandSequenceRequest, self).__init__(**kwargs)
    #Get input files from commands
    self._more_inputfiles=getattr(self,'_more_inputfiles',[]) #Initialize attribute if it doesn't already exist
    self._more_inputfiles+=self.list_iofiles(self.commands,['filename','infpath'],'_inputfiles')
    #Get output files from commands
    self._more_outputfiles=getattr(self,'_more_outputfiles',[]) #Initialize attribute if it doesn't already exist
    self._more_outputfiles+=self.list_iofiles(self.commands,['filename','outfpath'],'_outputfiles')
  def run(self):
    #Final checks and preparatory steps
    self.pre_run()
    #Run the comamnd sequence
    self.process_command_sequence(attrpath='commands',singlefunc=None,positional=False)


#Register for loading from yaml
yaml_manager.register_classes([CommandSequenceRequest])
